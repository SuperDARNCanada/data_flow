#!/bin/bash
# Copyright 2022 SuperDARN Canada, University of Saskatchewan
# Author: Theodore Kolkman
#
# This script distributes borealis rawacf dmap (bz2) and array (HDF5) 
# data to the following organizations/locations
#   Backs up dmap and array data to campus NAS
#   Stages dmap and array data for the mirror
#   Stages dmap data for sending to British Antarctic Survey (BAS), 
#       Virginia Tech (VT) and National Space Science Center (NSSC)
# Checks all files for integrity and place them in the correct location
# if all tests are passed. If any tests fail, the file isn't transferred
# and a log file explaining what happened is sent to the Engineering 
# dashboard
#
# Based on auto_borealis_share written by Kevin Krieger
#
# Dependencies:
#   - hdf5 (zypper in hdf5)
#
# Usage: ./distribute_borealis_data RADAR_ID
# Parameter RADAR_ID: [sas, pgr, rkn, inv, cly]

##############################################################################

# Specify error behaviour
set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes

# readonly HOME_DIR="/home/mrcopy"  # ${HOME} doesn't work since script is run by root
HOME_DIR=/home/radar #TESTING

# Load in functions
source "${HOME}/data_flow/library/data_flow_functions.sh"

##############################################################################

readonly RADAR_ID=$1

# Define directories
TEST_DIR=/home/radar/testing/data_flow_testing
readonly SOURCE="${TEST_DIR}/sddata/${RADAR_ID}_data"
readonly NAS_DIR="${TEST_DIR}/data/borealis_site_data"
readonly MIRROR_STAGING_DIR="${TEST_DIR}/data/holding/globus"
readonly BAS_STAGING_DIR="${TEST_DIR}/home/bas/outgoing/${RADAR_ID}"
readonly VT_STAGING_DIR="${TEST_DIR}/home/vtsd/outgoing/${RADAR_ID}"
readonly NSSC_STAGING_DIR="${TEST_DIR}/home/nssc/outgoing/${RADAR_ID}"

# Data group for outgoing files
# readonly DATA_GROUP="sddata"
DATA_GROUP=users    # TESTING

# Flag received from rsync_to_nas script to trigger this script
readonly FLAG_IN="${HOME_DIR}/data_flow/.inotify_watchdir/.rsync_on_campus_flag_${RADAR_ID}"

# Location of inotify watch directory for flags on site linux
readonly FLAG_DEST="${HOME_DIR}/data_flow/.inotify_watchdir"

# Flag sent out to trigger rsync_to_campus script
readonly FLAG_OUT="${HOME_DIR}/data_flow/.inotify_flags/.distribute_borealis_data_flag_${RADAR_ID}"


# Create log file. New file created daily
readonly LOGGING_DIR="${HOME_DIR}/logs/distribute_borealis_data/$(date +%Y)/$(date +%m)"
mkdir --parents --verbose $LOGGING_DIR
readonly LOGFILE="${LOGGING_DIR}/${RADAR_ID}.$(date +%Y%m%d).distribute_borealis_data.log"
readonly  SUMMARY_DIR="${HOME_DIR}/logs/distribute_borealis_data/summary/$(date +%Y)/$(date +%m)"
mkdir --parents --verbose $SUMMARY_DIR
readonly SUMMARY_FILE="${SUMMARY_DIR}/${RADAR_ID}.$(date -u +%Y%m%d).distribute_summary.log"

##############################################################################

# Redirect all stdout and sterr in this script to $LOGFILE
exec &> $LOGFILE

printf "################################################################################\n\n" | tee --append $SUMMARY_FILE

printf "Executing $(basename "$0") on $(hostname)\n" | tee --append $SUMMARY_FILE
date --utc "+%Y%m%d %H:%M:%S UTC" | tee --append $SUMMARY_FILE

#### TODO: Do we need a file lock? Multiple instances of this script may be
#### running at same time for each site. Is this okay? Should we prevent this
#### or add some safety checks?
# Ensure that only a single instance of this script runs for this site
# if pidof -o %PPID -x -- "$(basename -- $0) ${RADAR_ID}" > /dev/null; then
#     echo "Error: Script $0 is already running. Exiting..."
#     exit 1
# fi

dmap_files=$(find ${SOURCE} -name "*rawacf.bz2")
array_files=$(find ${SOURCE} -name "*rawacf.hdf5")

if [[ -n $dmap_files ]]; then
    printf "\nDistributing the following dmap files:\n" 
    printf '%s\n' "${dmap_files[@]}"
else
    printf "\nNo dmap files found to be transferred.\n"
fi

# Iterate over all dmap files to be transferred
for file in $dmap_files; do
    bzip2 --test $file
    if [[ $? -eq 2 ]]; then
        printf "\nDMAP file failed bzip2 test: ${file}\n" | tee --append $SUMMARY_FILE
        # TODO: Set a flag to notify
    else
        printf "\nDistributing ${file}\n"
        chmod --verbose 664 $file

        file_name=$(basename $file)

        # TODO: Do we want to do rsync here instead?
        # TODO: Review changing of groups and permissions differring across destinations

        # Flag will be > 0 if any transfers fail since verify_transfer
        # returns 1 for failed transfer
        transfer_flag=0

        # Place file in vtsd outgoing
        cp --preserve --verbose "${file}" "${VT_STAGING_DIR}/"
        chgrp --verbose $DATA_GROUP "${VT_STAGING_DIR}/${file_name}"   
        echo "verify_transfer ${file} ${VT_STAGING_DIR}/${file_name}"
        verify_transfer "${file}" "${VT_STAGING_DIR}/${file_name}" 
        return_value=$?
        echo "return_value: $return_value"
        transfer_flag=$(($transfer_flag + $return_value))

        # Place file in BAS outgoing
        cp --preserve --verbose "${file}" "${BAS_STAGING_DIR}/"
        chgrp --verbose $DATA_GROUP "${BAS_STAGING_DIR}/${file_name}"
        verify_transfer "${file}" "${BAS_STAGING_DIR}/${file_name}"
        return_value=$?
        echo "return_value: $return_value"
        transfer_flag=$(($transfer_flag + $return_value))

        # Place file in NSSC outgoing - Uncommment this when NSSC is ready
        # cp --preserve --verbose "${file}" "${NSSC_STAGING_DIR}/"
        # chgrp --verbose $DATA_GROUP "${NSSC_STAGING_DIR}/${file_name}"
        # verify_transfer "${file}" "${NSSC_STAGING_DIR}/${file_name}"
        # return_value=$?
        # transfer_flag=$(($transfer_flag + $return_value))

        # Copy for staging to the mirror
        cp --preserve --verbose "${file}" "${MIRROR_STAGING_DIR}/"
        verify_transfer "${file}" "${MIRROR_STAGING_DIR}/${file_name}"
        return_value=$?
        echo "return_value: $return_value"
        transfer_flag=$(($transfer_flag + $return_value))

        # Check that all files were copied successfully
        # If any transfers failed, leave file in directory so tranfer
        # can be attempted the next time the script runs
        if [[ "${transfer_flag}" -eq 0 ]]; then
            echo "File distribution successful: ${file}" | tee --append $SUMMARY_FILE

            # Move file to campus NAS for long term storage
            year=$(echo ${file_name} | cut --characters 1-4)
            month=$(echo ${file_name} | cut --characters 5-6)
            nas_site_dir="${NAS_DIR}/${RADAR_ID}_rawacf_dmap/${year}/${month}/"
            mkdir --parents $nas_site_dir
            mv --verbose $file $nas_site_dir
        else
            echo "File distribution failed: ${file}" | tee --append $SUMMARY_FILE
        fi
    fi
done


# Iterate over all array files and back them up to NAS
if [[ -n $array_files ]]; then
    printf "\nDistributing the following array files:\n" 
    printf '%s\n' "${array_files[@]}"
else
    printf "\nNo array files found to be transferred.\n"
fi

for file in $array_files; do
    h5stat $file >& /dev/null
    if [[ $? -ne 0 ]]; then
        printf "\nArray file failed h5stat test: ${file}\n" | tee --append $SUMMARY_FILE
    else
        printf "\nDistributing ${file}\n"
        chmod --verbose 664 "${file}"

        file_name=$(basename $file)

        # TODO: Do we want to do rsync here instead?
        # TODO: Review changing of groups and permissions differring across destinations

        # TODO: array files aren't synced to mirror - do we still want to back them up in the holding directory?

        year=$(echo ${file_name} | cut --characters 1-4)
        month=$(echo ${file_name} | cut --characters 5-6)
        nas_site_dir="${NAS_DIR}/${RADAR_ID}_rawacf/${year}/${month}/"
        mkdir --parents $nas_site_dir
        mv --verbose $file $nas_site_dir
        printf "File distribution successful: ${file}\n" | tee --append $SUMMARY_FILE
    fi
done

# TODO: Send error file to Engineering dashboard
printf "\nTriggering next script via inotify...\n"
# Remove "flag" sent by convert_and_restructure to reset flag
# and allow inotify to see the next flag sent in
touch $FLAG_IN # TESTING
rm --verbose $FLAG_IN

# Send out "flag" to trigger next script with inotify
touch $FLAG_OUT
rsync -av --rsh=ssh $FLAG_OUT $FLAG_DEST

printf "\nFinished file conversion. End time: $(date --utc "+%Y%m%d %H:%M:%S UTC")\n\n" | tee --append $SUMMARY_FILE

exit
